\setcounter{equation}{0}

\chapter{Introduction}
\label{chap:introduction}

\section{Motivation}
The increasing complexity of current and future systems have made the task of a designer difficult and time consuming. There has also been an increased focus on time to market these designs. These factors have contributed to a growing need for a higher level of design abstraction in order to increase design productivity. A typical system design cycle involves, first building performance and functional models using C/C++/SystemC and then using HDL(Hardware Description Language) for the actual design phase. If we can combine these two phases of architecture exploration and design, then we can significantly decrease our design time.

To address the above issues, we are building a fast FPGA prototyping tool chain to explore various GPGPU based architectures. The tool chain allows us to use the same code written in C++ to be translated to verilog and also used for our simulation framework (SST \cite{SST}).
Field Programmable Gate Arrays (FPGAs) have been used to prototype hardware designs, for emulation and as accelerators. Since they are hardware implementation of the design they are very fast to run tests and simulations before actually taping out an ASIC. FPGAs are used standalone also to implement highly parallel and configurable application specific designs. Having this emulation platform will allow us to run full feature applications which are generally the problem when running software simulations. For example to run an application on the simulator (MacSim used in this study, \cite{macsim}) we first need to trace the application and then run the trace on the simulator. Since the simulator is slow we trace only a small portion (hot loop) of the application. Whereas on the FPGA we can run the whole application without having to generate traces. For an application which has say a billion instructions running on the simulator like MacSim which runs at generally 50 kips(kilo instructions per second) takes around 5 hours where as running on the FPGA (\~ 200 MHz) might take us only a few seconds. The biggest difference or downside when running applications on an FPGA rather than an ASIC is the speed of the FPGA logic, for example the Altera Stratix III FPGA used for this work can run only till about \~500MHz where as an ASIC can run at much higher speed. The modern day FPGA tools make prototyping (implementation and debugging) a relatively easy task as compared to ASIC flow hence this approach was taken.

The aim of this wok was to create a tool chain to prototype general purpose graphics processing unit on FPGAs. This hardware flow combined with the higher level simulation flow using the same source code creates this whole tool chain to study future architectures using new technologies quickly. Most of the work in research has focused on either the simulation flow or the hardware flow. Having this flow for research would allow us to explore hardware designs and show results on the real prototype. %Although there are many research works who have published results for simulation and hardware but this is generally a very long process. 
In this work we demonstrate how we were able to create a full system on an FPGA and quickly try out various options. We created different systems using our parameterizable building blocks in a plug and play fashion. We started with building simple cores and then moved on to make bigger cores with SIMD support. Then we demonstrated systems with multiple cores and also heterogeneous systems consisting of a big core and multiple small cores. All this helped us meet our goal of quickly prototyping complex systems.

\section{Organization}
The thesis is organized as follows:
\\ 
\noindent\textbf{Chapter 2} gives an overview of the overall system which was prototyped. It also discusses about the various tools used and also gives an overview of CHDL which is the programming language used to write most of the system design code.
\\
\noindent\textbf{Chapter 3} Describes each of the system components in more detail. We mainly cover some details of the ISA used, the design of the core, the cache and the memory controller. Many obvious micro-architecture details have been skipped to keep the descriptions brief. After discussing about the system components we then discuss about how we went on to integrate all these components and create example designs.
\\
\noindent\textbf{Chapter 4} shows the simulation setup along with some of the results obtained. We also show the resource consumption by the design on the FPGA board.
\\
\noindent\textbf{Chapter 5} discusses related work. It also concludes the work and discusses future directions. 

