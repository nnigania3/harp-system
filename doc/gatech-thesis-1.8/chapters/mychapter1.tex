\setcounter{equation}{0}

\chapter{Introduction}
\label{chap:introduction}

\section{Motivation}
The increasing complexity of current and future systems have made the task of a designer difficult and time consuming. There has also been an increased focus on the time taken to market these designs. These factors have contributed to a growing need for a higher level of design abstraction in order to increase design productivity. A typical system design cycle involves first building performance and functional models using C/C++/SystemC and then using hardware description language (HDL) for the actual design phase. If we can combine these two phases of architecture exploration and design, we can significantly decrease our design time.

To address the above issues, we are building a fast FPGA prototyping tool chain to explore various GPGPU-based architectures. The tool chain allows us to use the same code written in C++ to be translated to Verilog and also used for our simulation framework (SST \cite{SST}).
Field programmable gate arrays (FPGAs) have been used to prototype hardware designs, for emulation and as accelerators. Since they are hardware implementations of the design, they run tests and simulations very fast before actually taping out an application specific integrated circuit (ASIC). FPGAs are also used as standalones to implement highly parallel and configurable application-specific designs. Having this emulation platform will allow us to run full-feature applications, which are generally the problem when running software simulations. For example, to run an application on the simulator (MacSim used in this study \cite{macsim}), we first need to trace the application and then run the trace on the simulator. Since the simulator is slow, we trace only a small portion (hot loop) of the application, whereas on the FPGA we can run the whole application without having to generate traces. For an application that has, say, a billion instructions, running it on simulator like MacSim, which runs at generally 50 kips (kilo instructions per second), takes around five hours, whereas running it on the FPGA (\~ 200 MHz) might take only a few seconds. The biggest difference or downside when running applications on an FPGA rather than an ASIC is the speed of the FPGA logic; for example, the Altera Stratix III FPGA used for this work can run only until about \~500MHz, whereas an ASIC can run at a much higher speed. The modern-day FPGA tools make prototyping (implementation and debugging) a relatively easy task compared to ASIC flow, hence this approach was taken.

The aim of this wok was to create a tool chain to prototype general-purpose graphics processing units on FPGAs. This hardware flow combined with the higher-level simulation flow using the same source code creates this whole tool chain to study future architectures, using new technologies. Most of the  research has focused on either the simulation flow or the hardware flow. Having this flow for research would allow us to explore hardware designs and show results on the real prototype. %Although there are many research works who have published results for simulation and hardware but this is generally a very long process. 
In this work we demonstrate how we were able to create a full system on an FPGA and quickly try out various options. We created different systems using our parameterizable building blocks in a plug-and-play fashion. We started by building simple cores and then moved on to make bigger cores with single instruction multiple data (SIMD) support. Then, we demonstrated systems with multiple cores and also heterogeneous systems consisting of a large/big core and multiple small cores. All this helped us meet our goal of quickly prototyping complex systems.

\section{Organization}
The thesis is organized as follows:
\\ 
\noindent\textbf{Chapter 2} gives an overview of the overall system that was prototyped. It also discusses the various tools used and also gives an overview of CHDL, which is the programming language library used to write most of the system design code.
\\
\noindent\textbf{Chapter 3} describes each of the system components in more detail. We mainly cover some details of the ISA used, the design of the core, the cache, and the memory controller. Many obvious micro-architecture details have been omitted to keep the descriptions brief. After discussing the system components, we then discuss how we integrated all of these components and created example designs.
\\
\noindent\textbf{Chapter 4} shows the simulation setup along with some of the results obtained. We also show the resource consumption of the design on the FPGA board.
\\
\noindent\textbf{Chapter 5} discusses related work. It also concludes the work and discusses future directions. 

