\setcounter{equation}{0}

\chapter{Future Work and Conclusion }
\label{Future Work and Conclusion }
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Related Work}
 A lot of literature can be found which demonstrate a framework to translate C/C++ code or higher abstractions to HDLs like Verilog/VHDL for hardware design. But not much work exists which demonstrate using the same source code for software simulation as well as hardware prototyping for architectural exploration purposes, some summary of prior work can be found here \cite{hls_overview}. \cite{SAC} proposes a new programming language inspired from C/C++. \cite{trident} focuses on creating RTL for floating point algorithms written in C. \cite{ROCC} does compile time optimization of the application to find regions of code which can be accelerated on FPGAs and it then generates VHDL for only those regions. \cite{reactivity} proposes something very much similar to SystemC with not much flexibility to integrate it with regular C++ or verilog models. \cite{hls_pipeline} talks about how to generate variable pipelined functional units from high level abstractions of HDL. \cite{hadi_dcim} discusses hardware/software codesign and simulation infrastructure for embedded systems. A good design of an example system using these translation tools was shown in \cite{piranha} and this work is very much similar to our work. But again the research does not focus on architecture flexibility and exploration, instead in looks into designing a complex system in the least time with their own framework. Our work allows us to use a general open source simulation framework SST \cite{SST} to do more high level coarse grained architecture exploration.
 
Most of the prior work focussed too deeply on generating optimal HDL code from C/C++ code and showed results on the FPGA comparing it with original verilog/VHDL implementations. They were either too application focussed or  involved a big learning curve for the programmer, which has prevented broad acceptance of these HSL (High Level Synthesis) frameworks as they missed out on showcasing its impact on future systems. \cite{hls_overview} gives a good overview of current HLS frameworks but again is bit more inclined towards the hardware synthesis part. In this work we took a look at the broader picture. We thought given we have something which translates C/C++ code to HDL and also be able to use it for our software simulation what kind of possible architectures can be easily explored. The work mentioned in this thesis was focussed on the FPGA flow side of things but the overall aim of the whole project is still focussed towards future possible architecture exploration.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Future Work}
Since this work is part of a multi-year and multi-person project many extensions are planned for this work. As for changes in the core part of the design, changes like adding support to handle multiple warps, branch divergence using mask registers will be one important feature which will make this design truly comparable to modern day GPGPUs. Also a feature like data forwarding can be added if we find that making the core more CPU like will be beneficial for certain kind of systems.

The applications written right now were all in Harp assembly but to allow us to run of the shelf CUDA or OpenCL applications a software translator tool is being worked upon wich can generate Harp assembly from these binaries.

The next major part of the future work is to explore future systems using new memory technologies like the HMC (Hyper Memory Cube) \cite{hmc}. Building these systems would require only isolated changes to the existing design. For example to use a FPGA board with HMC we would only have to generate a new Memory Interface IP for the HMC (as the controller is integrated in the logic layer of the HMC) and use this with the rest of the system.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Conclusion}
To conclude we showcased a tool chain and possible designs to allow quick prototyping of GPGPU designs on real hardware. Integrating the FPGA protyping flow with software simulation infrastructure will allow us to explore future architectures at different levels of granulatiry. By creating a parameterized design we can change many aspects of our design to affect performance under given design constraints. The flexibility offered by CHDL was also shown which allowed us to easily add more features to our system if needed like SIMD support. We were able to see benefits of the SIMD version of the core using a coalescing unit over the single lane version. This work also discussed few different systems which were emulated on hardware with only minor changes to the base design flow. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
