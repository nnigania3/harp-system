\setcounter{equation}{0}

\chapter{Future Work and Conclusion }
\label{Future Work and Conclusion }
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Related Work}
Much literature can be found that demonstrates a framework to translate C/C++ code or higher abstractions to HDLs like Verilog/VHDL for hardware design. But not much work exists that demonstrates using the same source code for software simulation as well as hardware prototyping for architectural exploration purposes; a summary of prior work can be found here \cite{hls_overview}. In \cite{SAC} the author proposes a new programming language inspired by C/C++. The work presented in \cite{trident} focuses on creating RTL for floating point algorithms written in C. The authors in \cite{ROCC}, do compile time optimization of the application to find regions of code that can be accelerated on FPGAs and then generate VHDL for only those regions. Something very similar to SystemC was presented in \cite{reactivity}, with not much flexibility to integrate it with regular C++ or Verilog models. The authors in \cite{hls_pipeline} talk about how to generate variable pipelined functional units from high-level abstractions of HDL. A hardware/software codesign and simulation infrastructure for embedded systems was presented in \cite{hadi_dcim}. A good design of an example system using these translation tools is shown in \cite{piranha} and this work is very similar to our work. But, again, the research does not focus on architecture flexibility and exploration; instead it looks into designing a complex system in the least amount of time using the author's framework. Our work allows us to use a general open source simulation framework SST \cite{SST} to do more high-level coarse grained architecture exploration.
 
Most of the prior work focussed too deeply on generating optimal HDL code from C/C++ code and showed results on the FPGA comparing it with original Verilog/VHDL implementations. These works were either too application focussed or  involved a major learning curve for the programmer, which has prevented broad acceptance of these HSL frameworks, as they missed out on showcasing its impact on future systems. A good overview of current HLS frameworks can be found in \cite{hls_overview} but again it is a bit more inclined towards the hardware synthesis part. In this work we took a look at the broader picture. Given that we have something that translates C/C++ code to HDL and can also be used for our software simulation, we wondered what kind of possible architectures could be easily explored. The work mentioned in this thesis focused on the FPGA flow side of things, but the overall aim of the whole project is still focused on future possible architecture exploration.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Future Work}
Since this work is part of a multi-year, multi-person project, many extensions are planned for this work. As for changes in the core part of the design, changes like adding support to handle multiple warps, and branch divergence using mask registers will be one important feature that will make this design truly comparable to modern-day GPGPUs. Also a feature like data forwarding can be added if we find that making the core more CPU like will be beneficial for certain kind of systems.

The applications written right now are all in HARP assembly, but to allow us to run of the shelf CUDA or OpenCL applications, a software translator tool is being worked on that can generate HARP assembly from these binaries.

The next major part of the future work is to explore future systems using new memory technologies like the HMC (Hybrid Memory Cube) \cite{hmc}. Building these systems would require only isolated changes to the existing design. For example, to use an FPGA board with HMC, we would only have to generate a new memory interface IP for the HMC (as the controller is integrated in the logic layer of the HMC) and use this with the rest of the system.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Conclusion}
To conclude, we showcased a tool chain and possible designs to allow quick prototyping of GPGPU designs on real hardware. Integrating the FPGA protyping flow with software simulation infrastructure will allow us to explore future architectures at different levels of granulatiry. By creating a parameterized design we can change many aspects of our design to affect performance under given design constraints. The flexibility offered by CHDL was also shown, which allowed us to easily add more features to our system if needed, like SIMD support. We were able to see benefits of the SIMD version of the core using a coalescing unit over the single lane version. This work also discussed a few different systems that were emulated on hardware with only minor changes to the base design flow. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
