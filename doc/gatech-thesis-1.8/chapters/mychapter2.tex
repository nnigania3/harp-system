\setcounter{equation}{0}

\chapter{Design Overview and Tool Chain}
\label{chap: Design Overview and Tool Chain}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{ System Overview }
The aim of this work was to design a custom GP-GPU as a starting point to explore future designs. Since we wanted the whole system to be customized, a custom ISA %(\cite{schreier}) 
called `HARP' was used for this work. The ISA is a MIPS based ISA with support for several customizations which will be discussed in the next section. The key features are predication support, configurable instruction width, no. of general purpose and predicate registers and vector support. 

As for the design, the main components are the core, the cache and the memory controller as can be seen in Figure~\ref{fig:system_overview}. Figure~\ref{fig:system_overview} is a very simple design which we have used just to demonstrate different components. Each of these components will be discussed separately in the next section. We will also look at the different possible systems we can design in Chapter 4. The core which implements the main pipeline and the memory management unit was written in `CHDL' which is our custom high level synthesis tool.%\cite{schreier}.
The cache was written in verilog and the memory controller IP was generated using Altera's FPGA tools (Quartus II, \cite{quartus}). Even though we have built a system using a particular configuration, we can use this flow to try many different scenarios. For example if we want to built a system which uses a new kind of memory system (example HMC \cite{hmc} ) all we would have to do is to replace the DDR2 controller which we are using right now with the IP of the new memory controller and everything else will remain the same. We can also add new instructions to the ISA and add support to the core (like support for multiple warps similar to commercial GPUs) keeping everything in the uncore part unchanged. 
\\
% LEFT, BOTTOM, RIGHT,TOP
 \figput{system_overview}{6.0in}{0.0in 0.5in 0.0in 0.2in}{Basic system components}

As we can see in Figure~\ref{fig:system_overview}, our design supports multiple cores and each core can support SIMD hence creating a GPGPU or a SIMD CPU as one would like to call it. To enable support for multiple cores we have also designed the arbitrator which sends requests from the private caches of each core to the shared cache. Also similar to the way GPGPUs are designed; our design does not support coherence among the private caches of each of the cores. So the programmer should be aware of this fact and must write code accordingly. For the current work most benchmarks are written in HARP assembly but one of the future tasks as part of this project is to design a CUDA / OpenCL to HARP translator which would allow us to run more general commercially available applications.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{ CHDL }
CHDL is the custom environment which was used to generate HDL (hardware description language) using C++. It has similarities to System C and other HSL (High Level Synthesis) languages \cite{hls_overview}. We used CHDL so that as previously mentioned the same code written in C++ can be used for the FPGA flow as well as the simulation flow. CHDL is implemented as a source to source translator which translates high level C++ to netlist/Verilog HDL. It offers a set of C++ libraries to support correct translation of code to its Verilog equivalent. Even though we write in C++ we still have to think to some extent as to how the generated verilog code will look like. For example, one thing to keep in mind is that assignments to wires (represented as a vector of Boolean) are continuous and we can assign the wire only once in our code. We will discuss some examples later which give a good overview of this framework.

%More details of CHDL along with examples can be found in Appendix A.
There are several advantages of taking the CHDL approach, as we write code in C++ it becomes easy to describe complex functions using simple code as compared to Verilog. Also since we already have a library of commonly used functions we can write code quickly, for example we have implementations of multiplexers, decoder, encoders, state machines etc. There are some down sides of using this high level synthesis approach though. Since we can describe lot of complex functionality using this approach hence it might not always generate the most optimal Verilog code. We can expect the Verilog compiler to optimize the code and remove redundancies but we would be able to generate better code if we write directly in Verilog. \cite{hls_overview} gives a good overview of HSL (High Level Synthesis) frameworks and discusses about the quality of HDL generated. Another downside of using this approach is that it is very hard to debug, as the signal/variable names are lost in the code generated and we have to specify signals using special debug statements if we want to preserve the name to help us in debugging. It is also hard to fix or improve a critical path in the design to improve the performance.%The verilog code is also huge in size and unreadable.

Figure~\ref{fig:chdl_simple_example} shows a simple example of code written using CHDL and compared with its verilog equivalent. The verilog code generated from CHDL is about 106 lines compared to about 10 lines in verilog. As can be seen this is a code for simple 5 bit counter. The verilog code is implied; as for the CHDL version, we represent the counter with as a vector of bool with 5 bits. The `Reg' statements translates to ``always@(posedge clk) output \textless= input;'' in verilog.
%\begin{quotation}    
%\centering always@(posedge clk) output \textless= input; 
%\end{quotation} 

% LEFT, BOTTOM, RIGHT,TOP
 \figput{chdl_simple_example}{4.8in}{0.0in 1.7in 0.0in 1.5in}{Simple Counter in CHDL and Verilog}

Similarly if we want to implement basic operations we can directly use statements like that shown in Figure~\ref{fig:chdl_alu_example}. This figure shows the implementation of a basic ALU where the final output is that coming out from the multiplexer which selects the correct output based on the  `op' signal which acts as the selector.

% LEFT, BOTTOM, RIGHT,TOP 
\figput{chdl_alu_example}{4.8in}{0.0in 0.4in 0.0in 0.5in}{Basic ALU in CHDL}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{FPGA board and Development Tools}
The FPGA board used for our experiment is a Terasic DE3 board. It uses an Altera FPGA for prototyping. The FPGA used is a Stratix III 3SL150 FPGA with 142,000 logic elements (LEs). The DE3 board also has support for DDR2 RAM, leds, 7-segement display and connectors to stack multiple boards. Figure~\ref{fig:fpga_board} shows a picture of the FPGA board used for this work. 
We used Altera's FPGA tools for development purposes. The Quartus 11.3 tool\cite{quartus} was used to synthesize the HDL and program the FPGA device via USB. We used ModelSim for the RTL and gate level simulation experiments. As for other tools used we also used open source tools like `iVerilog'\cite{iverilog} to compile our verilog code and dump wave signals to a file which we then viewed using `gtkwave' \cite{gtkwave}. The DDR2 was used along with Altera's DDR2 memory controller IP. More about the DDR2 controller will be discussed in the chapter 3. The Quartus tool with a built in IP generator called `Megacore wizard' was used to generate the memory controller IPs along with other commonly used IPs like PLLs for managing clocks.
% LEFT, BOTTOM, RIGHT,TOP
 \figput{fpga_board}{3.0in}{0.0in 0.0in 0.0in 0.0in}{Altera Stratix III Board \cite{de3_manual}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
