\begin{table}
  \centering
  \begin{tabular}{|l|c|}
    \hline
    \multicolumn{2}{|c|}{Harmonica Core} \\
    \hline
    FPGA:&Stratix III; 113,600 LEs\\
    Operating Freq:&\~90 MHz\\
    RAM(data), ROM(inst):& 1024KB, 1024KB\\
    Regs:& 8 32-bit Regs\\
    %Lanes -> 1
    FPGA Utilization:&4\%  (3,661 / 113,600 ALUTs)\\ \hline \hline
    \multicolumn{2}{|c|}{Full system} \\
    \hline
%FPGA:&Stratix III; 113,600 LEs\\
Operating Freq:&\~62.5 MHz\\
L1 / L2 cache:& 16KB / 128KB\\
Combinational ALUTs:&13\%	(14,446 / 113,600 ALUTs)\\
Total block memory bits:&27\%	(1,505,792 / 5,630,976 )\\
    \hline
%Logic utilization:&	21 %\\
%Regs:& 8 32-bit Regs\\
%No FPu
  \end{tabular}
  \caption{The Harmonica core in its default configuration takes up very little FPGA real estate.}
  \label{table:fpga}
\end{table}

One of the goals of the evaluation toolchain is to have the ability to quickly prototype some subset of the systems we are exploring on an FPGA.
The tools we have developed and adopted allow us to quickly tune system parameters and implement prototypes on FPGA boards and measure their performance.
We can use this process to guide parameter selection in other aspects of architecture simulation.

Our first FPGA board prototype is built around the Harmonica core.
Synthesizable Verilog code for the core was generated by compiling the Harmonica source with GCC and linking against the CHDL library.
This code was then compiled for an Altera Stratix III FPGA using Altera's Quartus II tool suite.
Simple test applications written in HARP assembly like array sum, sieve of Eratosthenes and bubble sort were used to verify the design.
The logic consumption of this simple design was tiny as can be seen in Table~\ref{table:fpga}.
With this flexible toolchain and a customizable ISA and core we are now able to quickly iterate, rapidly implementing modifications to our instruction set, core, and system architecture.
For example, adding support for new instructions, new types of branch predictor, different floating point unit designs, new cache designs and memory controllers, etc. was relatively easy.

Once the Harmonica core was running on the FPGA we integrated it with more complex modules to create a more complete system.
A 2-level non-blocking write-back cache written in Verilog was created and interfaced with the CHDL-based Harmonica code.
This cache is also parameterized.
Its size and number of ways, can be changed, and it can be used in multi-level configurations.
After integrating the cache we began integrating a DDR2 memory controller generated with Altera's MegaWizard tool with the core and cache.
The logic consumption of this design can be seen in Table~\ref{table:fpga}.

In summary, we created a system-level prototype consisting of a highly configurable core, cache and DDR2 memory controller.
Each of these components was individually tested before integration.
This flow will be helpful for future work in which we plan to use it to explore PNM architectures, e.g. by interfacing the FPGA prototype with Micron's Hybrid Memory Cube.
We will only have to obtain a new memory controller IP either from the vendor or add changes to an existing one.
This will also us to do various studies like what configuration of the logic layer will be best suited for this type of memory architecture and examine critical paths.
