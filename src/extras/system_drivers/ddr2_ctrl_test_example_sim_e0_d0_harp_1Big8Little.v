// ddr2_ctrl_test_example_sim_e0_d0.v

// This file was auto-generated from altera_avalon_mm_traffic_generator_hw.tcl.  If you edit it your changes
// will probably be lost.
// 
// Generated using ACDS version 13.0sp1 232 at 2013.08.30.12:07:55

`timescale 1 ps / 1 ps
module ddr2_ctrl_test_example_sim_e0_d0 #(
		parameter DEVICE_FAMILY                          = "Stratix III",
		parameter TG_AVL_DATA_WIDTH                      = 256,
		parameter TG_AVL_ADDR_WIDTH                      = 30,
		parameter TG_AVL_WORD_ADDR_WIDTH                 = 25,
		parameter TG_AVL_SIZE_WIDTH                      = 3,
		parameter TG_AVL_BE_WIDTH                        = 32,
		parameter DRIVER_SIGNATURE                       = 1431634050,
		parameter TG_GEN_BYTE_ADDR                       = 1,
		parameter TG_NUM_DRIVER_LOOP                     = 1,
		parameter TG_ENABLE_UNIX_ID                      = 0,
		parameter TG_USE_UNIX_ID                         = 0,
		parameter TG_RANDOM_BYTE_ENABLE                  = 1,
		parameter TG_ENABLE_READ_COMPARE                 = 1,
		parameter TG_POWER_OF_TWO_BURSTS_ONLY            = 0,
		parameter TG_BURST_ON_BURST_BOUNDARY             = 0,
		parameter TG_DO_NOT_CROSS_4KB_BOUNDARY           = 0,
		parameter TG_TIMEOUT_COUNTER_WIDTH               = 32,
		parameter TG_MAX_READ_LATENCY                    = 20,
		parameter TG_SINGLE_RW_SEQ_ADDR_COUNT            = 32,
		parameter TG_SINGLE_RW_RAND_ADDR_COUNT           = 32,
		parameter TG_SINGLE_RW_RAND_SEQ_ADDR_COUNT       = 32,
		parameter TG_BLOCK_RW_SEQ_ADDR_COUNT             = 8,
		parameter TG_BLOCK_RW_RAND_ADDR_COUNT            = 8,
		parameter TG_BLOCK_RW_RAND_SEQ_ADDR_COUNT        = 8,
		parameter TG_BLOCK_RW_BLOCK_SIZE                 = 8,
		parameter TG_TEMPLATE_STAGE_COUNT                = 4,
		parameter TG_SEQ_ADDR_GEN_MIN_BURSTCOUNT         = 1,
		parameter TG_SEQ_ADDR_GEN_MAX_BURSTCOUNT         = 4,
		parameter TG_RAND_ADDR_GEN_MIN_BURSTCOUNT        = 1,
		parameter TG_RAND_ADDR_GEN_MAX_BURSTCOUNT        = 4,
		parameter TG_RAND_SEQ_ADDR_GEN_MIN_BURSTCOUNT    = 1,
		parameter TG_RAND_SEQ_ADDR_GEN_MAX_BURSTCOUNT    = 4,
		parameter TG_RAND_SEQ_ADDR_GEN_RAND_ADDR_PERCENT = 50
	) (
		input  wire         clk,             // avl_clock.clk
		input  wire         clkby2,             // avl_clock.clk
		output wire [0:6]   disp1,
		output wire [0:6]   disp2,
		input  wire         reset_n,         // avl_reset.reset_n
		output wire         pass,            //    status.pass
		output wire         fail,            //          .fail
		output wire         test_complete,   //          .test_complete
		input  wire         avl_ready,                       //       avl.waitrequest_n
		output      [TG_AVL_ADDR_WIDTH-1:0]  avl_addr,       //          .address
		output      [TG_AVL_SIZE_WIDTH-1:0]   avl_size,      //          .burstcount
		output      [TG_AVL_DATA_WIDTH-1:0] avl_wdata,       //          .writedata
		input       [TG_AVL_DATA_WIDTH-1:0] avl_rdata,       //          .readdata
		output              avl_write_req,   		     //          .write
		output              avl_read_req,                    //          .read
		input               avl_rdata_valid,                 //          .readdatavalid
		output      [TG_AVL_BE_WIDTH-1:0]  avl_be,           //          .byteenable
		output              avl_burstbegin                   //          .beginbursttransfer
	);



	localparam LINE_BITS    = 5;
        localparam ADDR_WIDTH   = 32;
        localparam CREG_ID_BITS = 3;
        localparam WORDS        = 8;
        `ifdef SIMD
        localparam DATA_WIDTH   = 32 *WORDS;
        `else
        localparam DATA_WIDTH   = 32;
	`endif
	localparam LINE_WIDTH   = TG_AVL_DATA_WIDTH;//DATA_WIDTH*WORDS;

	wire led1;

	wire reset;	
	wire [31:0] addr_in; 		// address in from the core
	wire [DATA_WIDTH -1:0] data_in;	// data from the core
	wire rw_in; 			// read / write command
	wire valid_in; 			//  valid reg on the addr, data buses
	wire [2:0] id_in; 		// ld/st Q id for request
	
	wire [DATA_WIDTH-1:0] data_out;	// data to be given to the core
	wire [2:0] id_out;		// ld/st Q id for request being satisfied
	wire ready_out; 		// the memory request for which data is ready
	wire stall_out;			// the memory system cannot accept anymore requests

        wire cache_reset_n;
	wire [DATA_WIDTH-1:0] harp_data_out;	// data to be given to the core
	wire harp_ready_out; 			// the memory request for which data is ready
        `ifdef SIMD
        wire [WORDS-1:0] valid_word_in;
        `endif

//************Little Harp 1*******************
	wire [DATA_WIDTH-1:0] harp_data_out1;	// data to be given to the core
	wire harp_ready_out1; 	// the memory request for which data is ready
	harmonica1 harp1(
	  .phi(clk),
	  .char_out(harp_ready_out1),
	  .char_out_val(harp_data_out1)
       );

//************Little Harp 2*******************
	wire [DATA_WIDTH-1:0] harp_data_out2;	// data to be given to the core
	wire harp_ready_out2; 	// the memory request for which data is ready
	harmonica1 harp2(
	  .phi(clk),
	  .char_out(harp_ready_out2),
	  .char_out_val(harp_data_out2)
       );

//************Little Harp 3*******************
	wire [DATA_WIDTH-1:0] harp_data_out3;	// data to be given to the core
	wire harp_ready_out3; 	// the memory request for which data is ready
	harmonica1 harp3(
	  .phi(clk),
	  .char_out(harp_ready_out3),
	  .char_out_val(harp_data_out3)
       );

//************Little Harp 4*******************
	wire [DATA_WIDTH-1:0] harp_data_out4;	// data to be given to the core
	wire harp_ready_out4; 	// the memory request for which data is ready
	harmonica1 harp4(
	  .phi(clk),
	  .char_out(harp_ready_out4),
	  .char_out_val(harp_data_out4)
       );

//************Little Harp 5*******************
	wire [DATA_WIDTH-1:0] harp_data_out5;	// data to be given to the core
	wire harp_ready_out5; 	// the memory request for which data is ready
	harmonica1 harp5(
	  .phi(clk),
	  .char_out(harp_ready_out5),
	  .char_out_val(harp_data_out5)
       );

//************Little Harp 6*******************
	wire [DATA_WIDTH-1:0] harp_data_out6;	// data to be given to the core
	wire harp_ready_out6; 	// the memory request for which data is ready
	harmonica1 harp6(
	  .phi(clk),
	  .char_out(harp_ready_out6),
	  .char_out_val(harp_data_out6)
       );

//************Little Harp 7*******************
	wire [DATA_WIDTH-1:0] harp_data_out7;	// data to be given to the core
	wire harp_ready_out7; 	// the memory request for which data is ready
	harmonica1 harp7(
	  .phi(clk),
	  .char_out(harp_ready_out7),
	  .char_out_val(harp_data_out7)
       );

//************Little Harp 8*******************
	wire [DATA_WIDTH-1:0] harp_data_out8;	// data to be given to the core
	wire harp_ready_out8; 	// the memory request for which data is ready
	harmonica1 harp8(
	  .phi(clk),
	  .char_out(harp_ready_out8),
	  .char_out_val(harp_data_out8)
       );

//************BIG Harp 1*******************
	harmonica harp_core
		(
	           .phi(clk),
	           .cache_data_in(data_out),
	           .cache_id_in(id_out),
	           .cache_ready_in(ready_out),
	           .cache_stall_in(stall_out),
	           .reset_in(reset),
	           .cache_addr_out(addr_in),
	           .cache_data_out(data_in),
	           .cache_id_out(id_in),
	           .cache_reset_n(cache_reset_n),
	           .cache_rw_out(rw_in),
                   `ifdef SIMD
	           .cache_valid_word(valid_word_in),
                   `endif
	           .cache_valid_out(valid_in),
	           .char_out(harp_ready_out),
	           .char_out_val(harp_data_out)
               );

	cache_subsystem  #(
		.AVL_ADDR(ADDR_WIDTH),
		.AVL_SIZE(TG_AVL_SIZE_WIDTH),
		.AVL_BE(TG_AVL_BE_WIDTH),
		.AVL_DATA_WIDTH(LINE_WIDTH)
	)
	cache
		(
		clk,
		clkby2,
		cache_reset_n,
		addr_in, 		// address in from the core
		data_in, 		// data from the core
		rw_in, 			// read / write command
		valid_in, 		//  valid reg on the addr, data buses
		id_in, 			// ld/st Q id for request
                `ifdef SIMD
		valid_word_in, 		// ld/st Q id for request
                `endif
		data_out,		// data to be given to the core
		id_out,			// ld/st Q id for request being satisfied
		ready_out, 		// the memory request for which data is ready
		stall_out, 		// the memory system cannot accept anymore requests
                avl_ready,      
                avl_addr,       
                avl_size,       
                avl_wdata,      
                avl_rdata,      
                avl_write_req,  
                avl_read_req,   
                avl_rdata_valid,
                avl_be,         
                avl_burstbegin  		
	);

reg [9:0]count;
reg [31:0] reset_time;	//check we will reset again
reg stop;
reg [31:0]data_sum;

   initial begin
   	reset_time <= 0;
   end

//************Big harp1*******************
   always @ (posedge clk)
   begin
      reset_time <= reset_time + 1;
      if (reset == 1'b1) begin
	 data_sum <= 0;
	 stop <= 1'b0;	
      end else begin
	 if(harp_ready_out == 1'b1)	begin
		data_sum <= data_sum + harp_data_out[6:0];
		stop <= 1'b1;
	 end
      end
   end
//************Little Harp 1*******************
reg stop1;
reg [31:0]data_sum1;

   always @ (posedge clk)
   begin
      if (reset == 1'b1) begin
	 stop1     <= 0;	
	 data_sum1 <= 0;	
      end else begin
	 if(harp_ready_out1 == 1'b1) begin
		data_sum1 <= data_sum1 + harp_data_out1;
		stop1     <= 1'b1;
         end	
      end
   end
//************Little Harp 2*******************
reg stop2;
reg [31:0]data_sum2;

   always @ (posedge clk)
   begin
      if (reset == 1'b1) begin
	 stop2     <= 0;	
	 data_sum2 <= 0;	
      end else begin
	 if(harp_ready_out2 == 1'b1) begin
		data_sum2 <= data_sum2 + harp_data_out2;
		stop2     <= 1'b1;
         end	
      end
   end
//************Little Harp 3*******************
reg stop3;
reg [31:0]data_sum3;

   always @ (posedge clk)
   begin
      if (reset == 1'b1) begin
	 stop3     <= 0;	
	 data_sum3 <= 0;	
      end else begin
	 if(harp_ready_out3 == 1'b1) begin
		data_sum3 <= data_sum3 + harp_data_out3;
		stop3     <= 1'b1;
         end	
      end
   end
//************Little Harp 4*******************
reg stop4;
reg [31:0]data_sum4;

   always @ (posedge clk)
   begin
      if (reset == 1'b1) begin
	 stop4     <= 0;	
	 data_sum4 <= 0;	
      end else begin
	 if(harp_ready_out4 == 1'b1) begin
		data_sum4 <= data_sum4 + harp_data_out4;
		stop4     <= 1'b1;
         end	
      end
   end
//************Little Harp 5*******************
reg stop5;
reg [31:0]data_sum5;

   always @ (posedge clk)
   begin
      if (reset == 1'b1) begin
	 stop5     <= 0;	
	 data_sum5 <= 0;	
      end else begin
	 if(harp_ready_out5 == 1'b1) begin
		data_sum5 <= data_sum5 + harp_data_out5;
		stop5     <= 1'b1;
         end	
      end
   end
//************Little Harp 6*******************
reg stop6;
reg [31:0]data_sum6;

   always @ (posedge clk)
   begin
      if (reset == 1'b1) begin
	 stop6     <= 0;	
	 data_sum6 <= 0;	
      end else begin
	 if(harp_ready_out6 == 1'b1) begin
		data_sum6 <= data_sum6 + harp_data_out6;
		stop6     <= 1'b1;
         end	
      end
   end
//************Little Harp 7*******************
reg stop7;
reg [31:0]data_sum7;

   always @ (posedge clk)
   begin
      if (reset == 1'b1) begin
	 stop7     <= 0;	
	 data_sum7 <= 0;	
      end else begin
	 if(harp_ready_out7 == 1'b1) begin
		data_sum7 <= data_sum7 + harp_data_out7;
		stop7     <= 1'b1;
         end	
      end
   end
//************Little Harp 8*******************
reg stop8;
reg [31:0]data_sum8;

   always @ (posedge clk)
   begin
      if (reset == 1'b1) begin
	 stop8     <= 0;	
	 data_sum8 <= 0;	
      end else begin
	 if(harp_ready_out8 == 1'b1) begin
		data_sum8 <= data_sum8 + harp_data_out8;
		stop8     <= 1'b1;
         end	
      end
   end
//********************************************
   assign reset    = ~reset_n ;
   assign test_complete = stop & stop1 & stop2 & stop3 & stop4 & stop5 & stop6 & stop7 & stop8;
   wire   pass0, pass1, pass2, pass3, pass4, pass5, pass6,pass7,pass8, fail0, fail1, fail2, fail3, fail4, fail5, fail6,fail7,fail8; 
   //assign pass = (data_sum == 81)? 1'b1 : 1'b0 ; // for SUM 30*8=240 nos, both coal and uncoal
   //assign fail = (data_sum != 81)? 1'b1 : 1'b0 ; //
   assign pass0 = (data_sum == 12)? 1'b1 : 1'b0 ; // for 8x8 matmul
   assign fail0 = (data_sum != 12)? 1'b1 : 1'b0 ; //
   assign pass1 = (data_sum1 == 625)? 1'b1 : 1'b0 ;//for 10 bubble sort
   assign fail1 = (data_sum1 != 625)? 1'b1 : 1'b0 ;
   assign pass2 = (data_sum2 == 625)? 1'b1 : 1'b0 ;//for 10 bubble sort
   assign fail2 = (data_sum2 != 625)? 1'b1 : 1'b0 ;
   assign pass3 = (data_sum3 == 625)? 1'b1 : 1'b0 ;//for 10 bubble sort
   assign fail3 = (data_sum3 != 625)? 1'b1 : 1'b0 ;
   assign pass4 = (data_sum4 == 625)? 1'b1 : 1'b0 ;//for 10 bubble sort
   assign fail4 = (data_sum4 != 625)? 1'b1 : 1'b0 ;
   assign pass5 = (data_sum5 == 625)? 1'b1 : 1'b0 ;//for 10 bubble sort
   assign fail5 = (data_sum5 != 625)? 1'b1 : 1'b0 ;
   assign pass6 = (data_sum6 == 625)? 1'b1 : 1'b0 ;//for 10 bubble sort
   assign fail6 = (data_sum6 != 625)? 1'b1 : 1'b0 ;
   assign pass7 = (data_sum7 == 625)? 1'b1 : 1'b0 ;//for 10 bubble sort
   assign fail7 = (data_sum7 != 625)? 1'b1 : 1'b0 ;
   assign pass8 = (data_sum8 == 625)? 1'b1 : 1'b0 ;//for 10 bubble sort
   assign fail8 = (data_sum8 != 625)? 1'b1 : 1'b0 ;
   assign pass  = pass0 && pass1 && pass2 && pass3 && pass4 && pass5 && pass6 && pass7 && pass8;
   assign fail  = fail0 || fail1 || fail2 || fail3 || fail4 || fail5 || fail6 || fail7 || fail8;
   //********Perf Measurement**********
   reg[31:0] perf_counter;
   reg all_init_done;
   always@(posedge clk)
   begin
         if (reset == 1'b1) begin
   	 perf_counter <= 0;	
            all_init_done <= 1'b0;
         end else begin
            if (avl_ready == 1'b1)
               all_init_done <= 1'b1;
      
   `ifdef DUMMY_MEM	//When doing RLT simulations no need to check DDR init or not, else we wait till DDR init
            if((test_complete != 1'b1)) begin
   `else
            if((test_complete != 1'b1) && (all_init_done == 1'b1)) begin
   `endif
   	    perf_counter <= perf_counter + 1;	
            end
         end
   end
   de3_display_new  display(clk, perf_counter, pass, disp1, disp2, led1);
   //********************************

endmodule
