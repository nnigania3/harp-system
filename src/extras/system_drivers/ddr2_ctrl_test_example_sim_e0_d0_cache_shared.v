// ddr2_ctrl_test_example_sim_e0_d0.v

// This file was auto-generated from altera_avalon_mm_traffic_generator_hw.tcl.  If you edit it your changes
// will probably be lost.
// 
// Generated using ACDS version 13.0sp1 232 at 2013.08.30.12:07:55

`timescale 1 ps / 1 ps
module ddr2_ctrl_test_example_sim_e0_d0 #(
		parameter DEVICE_FAMILY                          = "Stratix III",
		parameter TG_AVL_DATA_WIDTH                      = 256,
		parameter TG_AVL_ADDR_WIDTH                      = 30,
		parameter TG_AVL_WORD_ADDR_WIDTH                 = 25,
		parameter TG_AVL_SIZE_WIDTH                      = 3,
		parameter TG_AVL_BE_WIDTH                        = 32,
		parameter DRIVER_SIGNATURE                       = 1431634050,
		parameter TG_GEN_BYTE_ADDR                       = 1,
		parameter TG_NUM_DRIVER_LOOP                     = 1,
		parameter TG_ENABLE_UNIX_ID                      = 0,
		parameter TG_USE_UNIX_ID                         = 0,
		parameter TG_RANDOM_BYTE_ENABLE                  = 1,
		parameter TG_ENABLE_READ_COMPARE                 = 1,
		parameter TG_POWER_OF_TWO_BURSTS_ONLY            = 0,
		parameter TG_BURST_ON_BURST_BOUNDARY             = 0,
		parameter TG_DO_NOT_CROSS_4KB_BOUNDARY           = 0,
		parameter TG_TIMEOUT_COUNTER_WIDTH               = 32,
		parameter TG_MAX_READ_LATENCY                    = 20,
		parameter TG_SINGLE_RW_SEQ_ADDR_COUNT            = 32,
		parameter TG_SINGLE_RW_RAND_ADDR_COUNT           = 32,
		parameter TG_SINGLE_RW_RAND_SEQ_ADDR_COUNT       = 32,
		parameter TG_BLOCK_RW_SEQ_ADDR_COUNT             = 8,
		parameter TG_BLOCK_RW_RAND_ADDR_COUNT            = 8,
		parameter TG_BLOCK_RW_RAND_SEQ_ADDR_COUNT        = 8,
		parameter TG_BLOCK_RW_BLOCK_SIZE                 = 8,
		parameter TG_TEMPLATE_STAGE_COUNT                = 4,
		parameter TG_SEQ_ADDR_GEN_MIN_BURSTCOUNT         = 1,
		parameter TG_SEQ_ADDR_GEN_MAX_BURSTCOUNT         = 4,
		parameter TG_RAND_ADDR_GEN_MIN_BURSTCOUNT        = 1,
		parameter TG_RAND_ADDR_GEN_MAX_BURSTCOUNT        = 4,
		parameter TG_RAND_SEQ_ADDR_GEN_MIN_BURSTCOUNT    = 1,
		parameter TG_RAND_SEQ_ADDR_GEN_MAX_BURSTCOUNT    = 4,
		parameter TG_RAND_SEQ_ADDR_GEN_RAND_ADDR_PERCENT = 50
	) (
		input  wire         clk,             // avl_clock.clk
		input  wire         clkby2,             // avl_clock.clk
		output wire [0:6]   disp1,
		output wire [0:6]   disp2,
		input  wire         reset_n,         // avl_reset.reset_n
		output wire         pass,            //    status.pass
		output wire         fail,            //          .fail
		output wire         test_complete,   //          .test_complete
		input  wire         avl_ready,       //       avl.waitrequest_n
		output      [TG_AVL_ADDR_WIDTH-1:0]  avl_addr,        //          .address
		output      [TG_AVL_SIZE_WIDTH-1:0]   avl_size,        //          .burstcount1
		output      [TG_AVL_DATA_WIDTH-1:0] avl_wdata,       //          .writedata
		input       [TG_AVL_DATA_WIDTH-1:0] avl_rdata,       //          .readata
		output              avl_write_req,   //          .write
		output              avl_read_req,    //          .read
		input               avl_rdata_valid, //          .readatavalid
		output      [TG_AVL_BE_WIDTH-1:0]  avl_be,          //          .byteenable
		output              avl_burstbegin   //          .beginbursttransfer
	);



	localparam LINE_BITS    = 5;
        localparam DATA_WIDTH   = 32;
        localparam ADDR_WIDTH   = 32;
        localparam CREG_ID_BITS = 3;
        localparam WORDS        = 8;
	localparam LINE_WIDTH   = TG_AVL_DATA_WIDTH;//DATA_WIDTH*WORDS;

	initial begin
		#999000000 $finish;
	end

	wire reset;	
	wire reset2;	
	wire [6:0]data_display1;
	wire [6:0]data_display2;
	wire led1;
	reg [31:0] addr_in1; 		// address in from the core
	reg [DATA_WIDTH -1:0] data_in1; 		// data from the core
	reg rw_in1; 								// read / write command
	wire valid_in1; 							//  valid reg on the addr, data buses
	reg [2:0] id_in1; 		// ld/st Q id for request
	
	wire [DATA_WIDTH-1:0] data_out1;	// data to be given to the core
	wire [2:0] id_out1;	// ld/st Q id for request being satisfied
	wire ready_out1; 						// the memory request for which data is ready
	wire stall_out1;							// the memory system cannot accept anymore requests
	reg [31:0] addr_in2; 		// address in from the core
	reg [DATA_WIDTH -1:0] data_in2; 		// data from the core
	reg rw_in2; 								// read / write command
	wire valid_in2; 							//  valid reg on the addr, data buses
	reg [2:0] id_in2; 		// ld/st Q id for request
	
	wire [DATA_WIDTH-1:0] data_out2;	// data to be given to the core
	wire [2:0] id_out2;	// ld/st Q id for request being satisfied
	wire ready_out2; 						// the memory request for which data is ready
	wire stall_out2;							// the memory system cannot accept anymore requests

	cache_shared  #(
		.AVL_ADDR(ADDR_WIDTH),
		.AVL_SIZE(TG_AVL_SIZE_WIDTH),
		.AVL_BE(TG_AVL_BE_WIDTH),
		.AVL_DATA_WIDTH(LINE_WIDTH)
	)
	shared_cache
		(
		clk,
		clkby2,
		reset,
		addr_in1, 		// address in from the core
		data_in1, 		// data from the core
		rw_in1, 								// read / write command
		valid_in1, 							//  valid reg on the addr, data buses
		id_in1, 		// ld/st Q id for request
		data_out1,	// data to be given to the core
		id_out1,	// ld/st Q id for request being satisfied
		ready_out1, 				// the memory request for which data is ready
		stall_out1, 							// the memory system cannot accept anymore requests
		
		addr_in2, 		// address in from the core
		data_in2, 		// data from the core
		rw_in2, 								// read / write command
		valid_in2, 							//  valid reg on the addr, data buses
		id_in2, 		// ld/st Q id for request
		data_out2,	// data to be given to the core
		id_out2,	// ld/st Q id for request being satisfied
		ready_out2, 				// the memory request for which data is ready
		stall_out2, 							// the memory system cannot accept anymore requests
                avl_ready,      
                avl_addr,       
                avl_size,       
                avl_wdata,      
                avl_rdata,      
                avl_write_req,  
                avl_read_req,   
                avl_rdata_valid,
                avl_be,         
                avl_burstbegin  		
	);

//************Cache2*******************
reg [9:0]count1;
reg stop1;
reg [31:0]data_sum1;

wire [31:0]data_display1_temp;
assign data_display1_temp = data_sum1;
assign data_display1 = data_display1_temp[11:5];


   always @ (posedge clk)
   begin
      if (reset == 1'b0) begin
       	 addr_in1  <= 32'd0;
       	 data_in1  <= {LINE_WIDTH{1'b0}};	//initial value
       	 rw_in1    <= 1;
       	 id_in1    <= 3'b000;
       	 count1    <= 1;
	 stop1     <= 0;	
	 data_sum1 <= 0;	
      end else begin
      	 if ( !stall_out1 && !stop1) begin
      	    count1    <= count1 + 1;
	    if ( count1 == 10'b1000000000)
               stop1 <= 1'b1;
      	    if(count1 < 10'b0100000000) begin
      	       rw_in1   <= 1'b1;
      	       addr_in1 <= {28'd0, count1[7:0]} * 4;
      	       data_in1 <= {count1[7:0]};
      	       id_in1   <= id_in1 + 3'b001;
      	    end else begin
      	       rw_in1   <= 1'b0;
      	       addr_in1 <= {28'd0, count1[7:0]} * 4;
      	     //data_in1 <= {0, count1[3:0]} + 100;
      	       id_in1   <= id_in1 + 3'b001;
      	    end
      	 end
	 if(ready_out1 == 1'b1)	
		data_sum1 <= data_sum1 + data_out1;
      end
   end
//************Cache1*******************

//************Cache2*******************
reg [9:0]count2;
reg stop2;
reg [31:0]data_sum2;

wire [31:0]data_display2_temp;
assign data_display2_temp = data_sum2;
assign data_display2 = data_display2_temp[11:5];


   always @ (posedge clk)
   begin
      if (reset2 == 1'b0) begin
       	 addr_in2  <= 32'd0 + 2*1024;
       	 data_in2  <= {LINE_WIDTH{1'b0}};	//initial value
       	 rw_in2    <= 1;
       	 id_in2    <= 3'b000;
       	 count2    <= 1;
	 stop2     <= 0;	
	 data_sum2 <= 0;	
      end else begin
      	 if ( !stall_out2 && !stop2) begin
      	    count2    <= count2 + 1;
	    if ( count2 == 10'b1000000000)
               stop2 <= 1'b1;
      	    if(count2 < 10'b0100000000) begin
      	       rw_in2   <= 1'b1;
      	       addr_in2 <= {28'd0, count2[7:0]} * 4 + 2*1024;
      	       data_in2 <= {count2[7:0]};
      	       id_in2   <= id_in2 + 3'b001;
      	    end else begin
      	       rw_in2   <= 1'b0;
      	       addr_in2 <= {28'd0, count2[7:0]} * 4 + 2*1024;
      	     //data_in2 <= {0, count2[3:0]} + 100;
      	       id_in2   <= id_in2 + 3'b001;
      	    end
      	 end
	 if(ready_out2 == 1'b1)	
		data_sum2 <= data_sum2 + data_out2;
      end
   end
//************Cache2*******************

assign valid_in2 = (!reset2 || stop2 || stall_out2) ? 1'b0 : 1'b1;
assign valid_in1 = (!reset || stop1 || stall_out1) ? 1'b0 : 1'b1;
assign reset    = reset_n ;
//assign reset2    = reset_n ;	//NN use this!
assign test_complete = stop1 && stop2;
wire pass1, pass2, fail1, fail2; 
assign pass1 = (data_sum1 == 32640)? 1'b1 : 1'b0 ;
assign fail1 = (data_sum1 != 32640)? 1'b1 : 1'b0 ;
assign pass2 = (data_sum2 == 32640)? 1'b1 : 1'b0 ;
assign fail2 = (data_sum2 != 32640)? 1'b1 : 1'b0 ;
assign pass = pass1 && pass2 ;
assign fail = fail1 || fail2 ;

//Display module
de3_display   display1(clk, data_display1, ready_out1, disp1, disp2, led1);
nn_reset_source #(.INITIAL_RESET_CYCLES(100)) reset_source(clk, reset2);

endmodule
